# 第四章：应用层设计

## 章节目标

完成应用层设计，包括：
1. **应用服务列表**：列出所有应用服务
2. **用户行为列表**：列出用户操作
3. **系统行为列表**：列出系统操作
4. **事件处理**：设计事件监听器，处理聚合根发布的领域事件
5. **服务详细设计**：设计每个应用服务的方法、职责、约束

---

## 输入来源

从 PRD 和第二、三章中提取以下信息：

| 来源 | 提取内容 | 转化目标 |
|------|---------|---------|
| PRD 用户操作 | 用户交互 | 用户行为列表 |
| PRD 系统操作 | 系统自动化 | 系统行为列表 |
| 第二章 聚合设计 | 聚合根行为中的事件发布 | 事件监听器设计 |
| 第三章 领域服务 | 领域服务 | 应用服务协调 |

---

## 生成步骤

### Step 1：区分用户行为 vs 系统行为

**目标**：区分用户操作和系统操作。

#### 1.1 用户行为特征

| 特征 | 说明 | 示例 |
|------|------|------|
| **用户发起** | 由用户操作触发 | 点击订阅按钮 |
| **需要权限控制** | 需要验证用户身份 | 只有会员才能查看 |
| **需要参数校验** | 需要校验输入参数 | 订阅金额必须 > 0 |

#### 1.2 系统行为特征

| 特征 | 说明 | 示例 |
|------|------|------|
| **系统触发** | 由系统事件触发 | 定时任务、事件监听 |
| **无用户交互** | 自动执行，无需用户介入 | 自动过期会员 |
| **无权限控制** | 不需要用户身份 | 系统内部操作 |

#### 1.3 行为分类决策树

```
这个行为是用户行为还是系统行为？
│
├─ 由用户发起吗？
│   ├─ 是 → 用户行为
│   └─ 否 → 继续
│
├─ 由事件触发吗？
│   ├─ 是 → 系统行为
│   └─ 否 → 继续
│
└─ 由定时任务触发吗？
    ├─ 是 → 系统行为
    └─ 否 → 需要进一步分析
```

---

### Step 2：应用服务列表

**目标**：列出所有应用服务。

#### 2.1 应用服务列表表格

| 服务名称 | 职责 | 对应聚合 | 对应领域服务 |
|---------|------|---------|-------------|
| {服务1} | {职责描述} | {聚合A} | {领域服务X} |
| {服务2} | {职责描述} | {聚合B} | - |

#### 2.2 应用服务命名规范

```
格式：{聚合名} + Application

示例：
✅ 好的服务命名
- MembershipApplication
- CouponApplication
- PaymentApplication

❌ 差的服务命名
- MembershipService（与领域服务混淆）
- MembershipApplicationService（啰嗦，不够简洁）
- MembershipController（Controller 层命名）
- 会员服务（中文，不符合代码规范）
```

---

### Step 3：用户行为列表

**目标**：列出所有用户操作。

#### 3.1 用户行为列表表格

| 行为名称 | 应用服务 | 聚合根方法 | 权限要求 |
|---------|---------|-----------|---------|
| {行为1} | {服务A} | {方法X} | {权限要求} |
| {行为2} | {服务B} | {方法Y} | {权限要求} |

#### 3.2 用户行为示例

| 行为名称 | 应用服务 | 聚合根方法 | 权限要求 |
|---------|---------|-----------|---------|
| 创建订阅 | MembershipApplication | Membership.create() | 登录用户 |
| 取消订阅 | MembershipApplication | Membership.cancel() | 会员本人 |
| 查看会员信息 | MembershipApplication | MembershipRepository.findById() | 登录用户 |

---

### Step 4：系统行为列表

**目标**：列出所有系统操作。

#### 4.1 系统行为列表表格

| 行为名称 | 触发条件 | 应用服务 | 聚合根方法 |
|---------|---------|---------|-----------|
| {行为1} | {触发条件} | {服务A} | {方法X} |
| {行为2} | {触发条件} | {服务B} | {方法Y} |

#### 4.2 系统行为示例

| 行为名称 | 触发条件 | 应用服务 | 聚合根方法 |
|---------|---------|---------|-----------|
| 会员过期 | 定时任务（每日凌晨） | MembershipApplication | Membership.expire() |
| 点券发放 | 会员激活事件 | CouponApplication | Coupon.grant() |
| 自动续费 | 订阅到期前1天 | MembershipApplication | Membership.renew() |

---

### Step 4.5：事件处理

> **核心原则**：领域事件在聚合根中产生，在应用层中消费
> - 事件产生侧：参见第二章"聚合设计"中聚合根行为设计的"事件发布"字段
> - 事件消费侧：在本小节中设计事件处理逻辑

**目标**：设计事件监听器，处理聚合根发布的领域事件。

#### 4.5.1 事件监听器识别

对每个领域事件，识别其监听器：

| 问题 | 说明 | 示例 |
|------|------|------|
| **有订阅方吗？** | 哪些上下文/服务需要响应 | 会员激活事件需要点券服务响应 |
| **处理逻辑是什么？** | 订阅方如何响应事件 | 开始每日点券发放 |
| **需要幂等性吗？** | 是否需要防止重复处理 | 通过 eventId 去重 |

#### 4.5.2 事件监听器列表表格

| 监听器名称 | 监听的事件 | 处理逻辑 | 影响的聚合 | 所属应用服务 |
|-----------|-----------|---------|-----------|-------------|
| {监听器1} | {事件1} | {逻辑描述} | {聚合A} | {当前服务} |
| {监听器2} | {事件2} | {逻辑描述} | {聚合B} | {当前服务} |

**事件监听器示例**：

| 监听器名称 | 监听的事件 | 处理逻辑 | 影响的聚合 | 所属应用服务 |
|-----------|-----------|---------|-----------|-------------|
| CouponGrantListener | MembershipActivatedEvent | 开始每日点券发放 | Coupon | CouponApplication |
| NotificationListener | MembershipActivatedEvent | 发送激活通知 | - | NotificationApplication |
| AuditListener | MembershipActivatedEvent | 记录激活日志 | AuditLog | AuditApplication |

#### 4.5.3 监听器详细设计

**基本信息**：

| 字段 | 说明 |
|------|------|
| 监听器名称 | {监听器名称} |
| 监听事件 | {事件名称} |
| 职责 | {简要描述监听器的核心职责} |

**处理步骤**：

1. **事件接收**：从事件总线接收 {事件名称}
2. **幂等性检查**：
   - 幂等键：`event:{事件名称}:{event.eventId}`
   - 已处理则直接返回
3. **参数校验**：
   - 校验 {字段1} 不为空
   - 校验 {字段2} 符合格式
4. **调用领域服务/聚合**：
   - 调用 {服务/聚合}.{方法}({参数})
5. **结果处理**：
   - 成功：标记已处理，记录日志
   - 失败：记录错误日志，根据配置决定是否重试

**异常处理**：

| 异常类型 | 处理方式 | 是否重试 |
|---------|---------|---------|
| {异常1} | {处理方式} | 是 |
| {异常2} | 发送到死信队列，告警 | 否 |

**幂等性保证**：

| 幂等键 | 存储位置 | 说明 |
|-------|---------|------|
| eventId | Redis/DB | 通过 eventId 去重，避免重复消费 |

**消费代码示例**：

```typescript
class {应用服务} {
  @EventListener
  async on{事件名称}(event: {事件名称}): Promise<void> {
    // 1. 幂等性检查
    const idempotentKey = `event:{事件名称}:${event.eventId}`
    const processed = await this.idempotentRepo.exists(idempotentKey)
    if (processed) {
      return  // 已处理，直接返回
    }

    try {
      // 2. 处理事件
      await this.{领域服务}.{方法}(event.{字段1})

      // 3. 标记已处理
      await this.idempotentRepo.save(idempotentKey)
      this.logger.info(`Event processed: ${event.eventId}`)
    } catch (error) {
      // 记录日志，不影响其他订阅方
      this.logger.error(`Failed to process event ${event.eventId}`, error)
      throw error  // 根据配置决定是否重试
    }
  }
}
```

---

### Step 5：应用服务详细设计

**目标**：设计每个应用服务的方法、职责、约束。

#### 5.1 方法签名

```typescript
async {方法名}(cmd: {Command类型}): Promise<{Result类型}>
```

#### 5.2 职责描述

{简要描述应用服务的核心职责}

**应用层职责**：
- 事务管理
- 调用领域层
- 发布领域事件
- 返回结果

#### 5.3 约束定义

| 约束ID | 类型 | 描述 | 伪代码 | 执行时机 |
|-------|------|------|-------|---------|
| APP-{服务缩写}-01 | 参数校验 | {约束描述} | `ASSERT {条件表达式}` | 执行时 |
| APP-{服务缩写}-02 | 权限校验 | {约束描述} | `ASSERT {条件表达式}` | 执行时 |

#### 5.4 用例设计

**Case-APP-N1: {正向场景}**

| Given | When | Then | 验证约束 |
|-------|------|------|---------|
| {前置状态} | {方法名}({参数}={值}) | {结果描述} | APP-{服务缩写}-01 ✓ |

**Case-APP-B1: {约束违反场景}**

| Given | When | Then | 违反约束 |
|-------|------|------|---------|
| {前置状态} | {方法名}({参数}={非法值}) | 拒绝，"{错误信息}" | APP-{服务缩写}-01 ✗ |

**Case-APP-E1: 边界场景**

| Given | When | Then | 验证约束 |
|-------|------|------|---------|
| {边界条件} | {方法名}({参数}={边界值}) | {结果描述} | APP-{服务缩写}-01 ✓ |

---

## 输出格式

### 1. 应用服务列表

| 服务名称 | 职责 | 对应聚合 | 对应领域服务 |
|---------|------|---------|-------------|
| {服务1} | {职责描述} | {聚合A} | {领域服务X} |
| {服务2} | {职责描述} | {聚合B} | - |

---

### 2. 用户行为列表

| 行为名称 | 应用服务 | 聚合根方法 | 权限要求 |
|---------|---------|-----------|---------|
| {行为1} | {服务A} | {方法X} | {权限要求} |
| {行为2} | {服务B} | {方法Y} | {权限要求} |

---

### 3. 系统行为列表

| 行为名称 | 触发条件 | 应用服务 | 聚合根方法 |
|---------|---------|---------|-----------|
| {行为1} | {触发条件} | {服务A} | {方法X} |
| {行为2} | {触发条件} | {服务B} | {方法Y} |

---

### 4. 事件监听器列表

| 监听器名称 | 监听的事件 | 处理逻辑 | 影响的聚合 | 所属应用服务 |
|-----------|-----------|---------|-----------|-------------|
| {监听器1} | {事件1} | {逻辑描述} | {聚合A} | {当前服务} |
| {监听器2} | {事件2} | {逻辑描述} | {聚合B} | {当前服务} |

---

### 4.1 监听器：{监听器名称}

**监听事件**：{事件名称}

**职责**：{简要描述监听器的核心职责}

**处理逻辑**：{详细描述处理步骤}

**处理步骤**：
1. **事件接收**：从事件总线接收 {事件名称}
2. **幂等性检查**：
   - 幂等键：`event:{事件名称}:{event.eventId}`
   - 已处理则直接返回
3. **参数校验**：
   - 校验 {字段1} 不为空
   - 校验 {字段2} 符合格式
4. **调用领域服务/聚合**：
   - 调用 {服务/聚合}.{方法}({参数})
5. **结果处理**：
   - 成功：标记已处理，记录日志
   - 失败：记录错误日志，根据配置决定是否重试

**异常处理**：

| 异常类型 | 处理方式 | 是否重试 |
|---------|---------|---------|
| {异常1} | {处理方式} | 是 |
| {异常2} | 发送到死信队列，告警 | 否 |

**幂等性保证**：

| 幂等键 | 存储位置 | 说明 |
|-------|---------|------|
| eventId | Redis/DB | 通过 eventId 去重，避免重复消费 |

---

### 5. 单个应用服务详细设计

#### 5.1 应用服务：{服务名称}

**基本信息**

| 字段 | 值 |
|------|-----|
| 服务名称 | {服务名称} |
| 职责 | {职责描述} |
| 对应聚合 | {聚合A} |
| 对应领域服务 | {领域服务X} |

**方法列表**

| 方法名 | 职责 | 调用的领域方法 |
|-------|------|--------------|
| {方法1} | {职责描述} | {聚合根}.{方法X}() |

---

#### 5.2 方法：{方法名1}(cmd)

**方法签名**

```typescript
async {方法名}(cmd: {Command类型}): Promise<{Result类型}>
```

**业务含义**

{方法的业务含义描述}

**前置条件**

- {前置条件1}
- {前置条件2}

**后置条件**

- {后置条件1}
- {后置条件2}

**约束定义**

| 约束ID | 类型 | 描述 | 伪代码 | 执行时机 |
|-------|------|------|-------|---------|
| APP-{服务缩写}-01 | 参数校验 | {约束描述} | `ASSERT {条件表达式}` | 执行时 |
| APP-{服务缩写}-02 | 权限校验 | {约束描述} | `ASSERT {条件表达式}` | 执行时 |

**用例设计**

**Case-APP-N1: {正向场景}**

| Given | When | Then | 验证约束 |
|-------|------|------|---------|
| {前置状态} | {方法名}({参数}={值}) | {结果描述} | APP-{服务缩写}-01 ✓ |

**Case-APP-B1: {约束违反场景}**

| Given | When | Then | 违反约束 |
|-------|------|------|---------|
| {前置状态} | {方法名}({参数}={非法值}) | 拒绝，"{错误信息}" | APP-{服务缩写}-01 ✗ |

**Case-APP-E1: 边界场景**

| Given | When | Then | 验证约束 |
|-------|------|------|---------|
| {边界条件} | {方法名}({参数}={边界值}) | {结果描述} | APP-{服务缩写}-01 ✓ |

---

## 质量检查

完成本章后，使用以下检查清单自检：

### 检查清单

- [ ] 所有应用服务已识别
- [ ] 用户行为和系统行为已区分
- [ ] 每个应用服务都有方法签名
- [ ] 每个应用服务都有职责描述
- [ ] 每个应用服务都有约束定义
- [ ] 每个应用服务都有用例设计
- [ ] 应用服务不包含业务逻辑（业务逻辑在领域层）
- [ ] 应用服务负责事务管理

### 评分标准

使用 [references/scoring/chapter-04-scoring.md](references/scoring/chapter-04-scoring.md) 评分。

**及格线**：60 分

**评分维度**：
- 服务识别（30 分）
- 服务设计（40 分）
- 约束定义（30 分）

---

## 常见问题

### Q1: 用户行为和系统行为的区别？

| 特征 | 用户行为 | 系统行为 |
|------|---------|---------|
| **发起者** | 用户 | 系统 |
| **触发方式** | 用户操作 | 事件/定时任务 |
| **权限控制** | 需要 | 不需要 |
| **示例** | 点击订阅按钮 | 自动过期会员 |

### Q2: 应用服务可以包含业务逻辑吗？

**原则**：应用服务不包含业务逻辑，业务逻辑在领域层。

```typescript
// ✅ 正确：应用服务只负责编排
class MembershipApplication {
  async createMembership(cmd: CreateMembershipCommand): Promise<Membership> {
    // 参数校验（应用层职责）
    this.validate(cmd)

    // 调用领域层（业务逻辑在领域层）
    const membership = Membership.create(cmd)

    // 保存（应用层职责）
    await this.repo.save(membership)

    // 发布事件（应用层职责）
    this.eventPublisher.publish(membership.getEvents())

    return membership
  }
}

// ❌ 错误：应用服务包含业务逻辑
class MembershipApplication {
  async createMembership(cmd: CreateMembershipCommand): Promise<Membership> {
    // 业务逻辑应该在领域层
    if (cmd.amount <= 0) {
      throw new Error("金额必须大于0")
    }

    const membership = new Membership()
    membership.status = "ACTIVE"
    membership.amount = cmd.amount

    await this.repo.save(membership)
    return membership
  }
}
```

### Q3: 应用服务调用领域服务还是聚合根？

**原则**：
- **优先调用聚合根**：直接操作聚合
- **需要时调用领域服务**：跨聚合或复杂计算

```typescript
// ✅ 正确：优先调用聚合根
class MembershipApplication {
  async cancelMembership(cmd: CancelMembershipCommand): Promise<void> {
    const membership = await this.repo.findById(cmd.membershipId)
    membership.cancel()  // 调用聚合根行为
    await this.repo.save(membership)
  }
}

// ✅ 正确：需要时调用领域服务
class MembershipApplication {
  async calculateTotalValue(cmd: CalculateValueCommand): Promise<Money> {
    const membership = await this.repo.findById(cmd.membershipId)
    // 调用领域服务（跨聚合或复杂计算）
    return this.valueService.calculate(membership)
  }
}
```
