# 第二章评分标准：聚合设计

> **满分**：100 分
> **及格分**：60 分
> **优秀线**：80 分
> **对应章节**：chapter-02-aggregate.md
> **对应原则**：aggregate.md

---

## 评分维度

| 维度 | 权重 | 评分要点 |
|------|------|---------|
| 聚合根识别 | 25 分 | 四问法判断、与实体区分、命名规范 |
| 聚合边界设计 | 35 分 | 黄金法则、强一致性边界、聚合间引用 |
| 实体与值对象 | 25 分 | 实体识别、值对象识别、不变性 |
| 聚合不变量 | 15 分 | 不变量识别、不变量实现、约束分类 |

---

## 一、聚合根识别（25 分）

### 1.1 聚合根判断四问法（10 分）

**满分**：10 分

**评分标准**：
- 优秀（90-100分）：所有聚合根都通过四问法正确判断
- 良好（80-89分）：90%以上聚合根判断正确
- 及格（60-79分）：70%以上聚合根判断正确
- 不及格（<60分）：低于70%聚合根判断正确

**检查项**：
- [ ] 有全局唯一标识吗？（2分）
- [ ] 负责维护一致性边界吗？（3分）
- [ ] 拥有独立的生命周期吗？（2分）
- [ ] 是外部访问的唯一入口吗？（3分）

**判断结果**：四个问题都答"是" → 聚合根候选

**扣分项**：
- 判断错误：将实体误判为聚合根扣 3 分/个
- 将值对象误判为聚合根扣 5 分/个

---

### 1.2 聚合根 vs 实体区分（10 分）

**满分**：10 分

**评分标准**：
- 优秀（90-100分）：聚合根与实体完全正确区分
- 良好（80-89分）：90%以上正确区分
- 及格（60-79分）：70%以上正确区分
- 不及格（<60分）：低于70%正确区分

**检查项**：
- [ ] 标识区分（3分）：聚合根有全局唯一 ID，实体有局部唯一 ID
- [ ] 访问方式（3分）：聚合根外部可直接访问，实体只能通过聚合根访问
- [ ] 生命周期（2分）：聚合根可独立创建删除，实体依赖聚合根
- [ ] 仓储（2分）：聚合根有专门仓储，实体无专门仓储

**对比表**：
| 维度 | 聚合根 | 实体 |
|------|--------|------|
| 标识 | 全局唯一 ID | 局部唯一 ID（通常无独立 ID） |
| 访问 | 外部可直接访问 | 只能通过聚合根访问 |
| 生命周期 | 独立 | 依赖聚合根 |
| 仓储 | 有专门仓储 | 无专门仓储 |
| 示例 | Order | OrderItem |

**扣分项**：
- 标识混淆：聚合根和实体标识混淆扣 2 分/处
- 访问方式错误：实体有独立仓储扣 3 分/处

---

### 1.3 聚合根命名（5 分）

**满分**：5 分

**评分标准**：
- 优秀（90-100分）：所有聚合根命名清晰，使用业务语言
- 良好（80-89分）：90%以上聚合根命名清晰
- 及格（60-79分）：70%以上聚合根命名清晰
- 不及格（<60分）：低于70%聚合根命名清晰

**检查项**：
- [ ] 使用业务语言命名（3分）：Order、Membership、Coupon
- [ ] 语义明确（2分）：名称能清晰表达业务含义

**扣分项**：
- 命名模糊：聚合根名称无法理解扣 2 分/个
- 使用技术术语：使用 DTO、Entity 等技术术语扣 1 分/个

---

## 二、聚合边界设计（35 分）

### 2.1 黄金法则：聚合尽可能小（10 分）

**满分**：10 分

**评分标准**：
- 优秀（90-100分）：所有聚合都是小聚合（1-3个实体，深度1-2层）
- 良好（80-89分）：90%以上聚合是小聚合
- 及格（60-79分）：70%以上聚合是小聚合，有部分聚合需要拆分
- 不及格（<60分）：低于70%聚合是小聚合或有多个大聚合

**检查项**：
- [ ] 聚合大小合理（7分）：
  - 小（1-3实体，深度1-2层）：7 分
  - 中（4-7实体，深度2-3层）：4 分（需要评估）
  - 大（8+实体，深度3+层）：0 分（需要拆分）
- [ ] 聚合根是唯一入口（3分）：外部只能通过聚合根访问聚合内部对象

**扣分项**：
- 聚合过大：聚合包含 8+ 个实体扣 5 分/个
- 深度过深：聚合深度 3+ 层扣 3 分/个
- 实体有独立仓储：不应该有实体的专门仓储扣 3 分/个

---

### 2.2 强一致性边界（10 分）

**满分**：10 分

**评分标准**：
- 优秀（90-100分）：聚合内部强一致，聚合间最终一致
- 良好（80-89分）：基本遵循一致性边界原则
- 及格（60-79分）：部分遵循一致性边界原则
- 不及格（<60分）：未遵循一致性边界原则

**检查项**：
- [ ] 聚合内强一致（5分）：聚合内数据必须在同一个事务中修改
- [ ] 聚合间最终一致（5分）：通过领域事件实现最终一致

**扣分项**：
- 聚合内不一致：聚合内数据未在同一个事务中修改扣 3 分/处
- 聚合间强一致：跨聚合使用强一致性扣 3 分/处

---

### 2.3 聚合间引用（10 分）

**满分**：10 分

**评分标准**：
- 优秀（90-100分）：所有聚合间引用只存储 ID，无对象引用
- 良好（80-89分）：90%以上聚合间引用使用 ID
- 及格（60-79分）：70%以上聚合间引用使用 ID
- 不及格（<60分）：低于70%聚合间引用使用 ID

**检查项**：
- [ ] 只存储 ID（7分）：聚合间引用只存储 ID，不存储对象引用
- [ ] ID 类型正确（3分）：使用类型化的 ID（如 UserId、OrderId）

**示例**：
```typescript
// ✅ 正确：只存储 ID
class Order {
  id: OrderId
  userId: UserId  // 只存储 ID
  items: OrderItem[]
}

// ❌ 错误：存储对象引用
class Order {
  id: OrderId
  user: User  // 不应该存储整个对象
  items: OrderItem[]
}
```

**扣分项**：
- 对象引用：聚合间直接引用对象扣 5 分/处
- ID 类型错误：使用原始类型 string 而非类型化 ID 扣 1 分/处

---

### 2.4 一个事务修改一个聚合（5 分）

**满分**：5 分

**评分标准**：
- 优秀（90-100分）：所有事务只修改一个聚合
- 良好（80-89分）：90%以上事务只修改一个聚合
- 及格（60-79分）：70%以上事务只修改一个聚合
- 不及格（<60分）：低于70%事务只修改一个聚合

**检查项**：
- [ ] 事务边界正确（5分）：一个事务只修改一个聚合

**示例**：
```typescript
// ✅ 正确：一个事务修改一个聚合
async function activateMembership(membershipId: string): Promise<void> {
  await db.transaction(async (tx) => {
    const membership = await membershipRepo.findById(membershipId, tx)
    membership.activate()
    await membershipRepo.save(membership, tx)
  })
}

// ❌ 错误：一个事务修改多个聚合
async function activateMembershipAndGrantCoupon(membershipId: string): Promise<void> {
  await db.transaction(async (tx) => {
    // 修改会员聚合
    const membership = await membershipRepo.findById(membershipId, tx)
    membership.activate()
    await membershipRepo.save(membership, tx)
    // 修改点券聚合（不应该在同一个事务）
    const coupon = await couponRepo.findByUserId(membership.userId, tx)
    coupon.addAmount(100)
    await couponRepo.save(coupon, tx)
  })
}
```

**扣分项**：
- 跨聚合事务：一个事务修改多个聚合扣 3 分/处

---

## 三、实体与值对象（25 分）

### 3.1 实体识别（10 分）

**满分**：10 分

**评分标准**：
- 优秀（90-100分）：所有实体通过四问法正确识别
- 良好（80-89分）：90%以上实体识别正确
- 及格（60-79分）：70%以上实体识别正确
- 不及格（<60分）：低于70%实体识别正确

**检查项**：
- [ ] 有唯一标识 (ID) 吗？（2分）：需要 ID 区分身份
- [ ] 需要追踪状态变化吗？（3分）：具有生命周期
- [ ] 属性变了还是同一个吗？（2分）：ID 不变身份依然存在
- [ ] 需要独立存储/检索吗？（3分）：脱离上下文仍有独立存在意义

**扣分项**：
- 将值对象误判为实体扣 3 分/个
- 将聚合根误判为实体扣 2 分/个

---

### 3.2 值对象识别（10 分）

**满分**：10 分

**评分标准**：
- 优秀（90-100分）：所有值对象通过四问法正确识别，且不可变
- 良好（80-89分）：90%以上值对象识别正确且不可变
- 及格（60-79分）：70%以上值对象识别正确且不可变
- 不及格（<60分）：低于70%值对象识别正确或可变

**检查项**：
- [ ] 只关注属性值吗（不需要 ID 区分身份）？（2分）
- [ ] 属性相同即可互换吗？（3分）
- [ ] 是不可变 (Immutable) 的吗（修改即替换整个对象）？（3分）
- [ ] 生命周期依附于他人吗（随宿主同时销毁）？（2分）

**值对象不可变验证**：
```typescript
// ✅ 正确：值对象不可变
class Money {
  readonly amount: bigint
  readonly currency: string

  add(other: Money): Money {
    return new Money(this.amount + other.amount, this.currency)  // 返回新对象
  }
}

// ❌ 错误：值对象可变
class Money {
  amount: bigint  // 可变
  currency: string

  add(other: Money): void {
    this.amount += other.amount  // 修改原对象
  }
}
```

**扣分项**：
- 将实体误判为值对象扣 3 分/个
- 值对象可变：值对象属性可变扣 4 分/个
- 值对象有 ID：值对象包含 ID 字段扣 2 分/个

---

### 3.3 实体 vs 值对象判断（5 分）

**满分**：5 分

**评分标准**：
- 优秀（90-100分）：实体和值对象完全正确区分
- 良好（80-89分）：90%以上正确区分
- 及格（60-79分）：70%以上正确区分
- 不及格（<60分）：低于70%正确区分

**检查项**：
- [ ] 判断标准明确（3分）：四个判断问题已列出
- [ ] 实际应用（2分）：所有对象都符合判断标准

**对比表**：
| 维度 | 实体 | 值对象 |
|------|------|--------|
| 标识 | 有 ID | 无 ID，用值判断相等 |
| 可变性 | 可变 | 不可变 |
| 生命周期 | 依赖聚合根 | 可独立存在 |

**扣分项**：
- 标准未列出：未列出判断条件扣 2 分
- 应用不一致：对象不符合标准扣 1 分/个

---

## 四、聚合不变量（15 分）

### 4.1 不变量识别（5 分）

**满分**：5 分

**评分标准**：
- 优秀（90-100分）：所有不变量都已识别
- 良好（80-89分）：90%以上不变量已识别
- 及格（60-79分）：70%以上不变量已识别
- 不及格（<60分）：低于70%不变量已识别

**检查项**：
- [ ] 状态约束（1分）：状态之间的排斥关系（如过期的订单不能修改）
- [ ] 数量约束（2分）：数量限制（如订单不能超过 10 个项目）
- [ ] 值约束（1分）：属性值范围（如金额不能为负）
- [ ] 引用约束（1分）：关联完整性（如订单项必须关联有效产品）

**扣分项**：
- 不变量缺失：遗漏关键不变量扣 2 分/个

---

### 4.2 不变量实现（7 分）

**满分**：7 分

**评分标准**：
- 优秀（90-100分）：所有不变量在聚合根方法中强制执行
- 良好（80-89分）：90%以上不变量强制执行
- 及格（60-79分）：70%以上不变量强制执行
- 不及格（<60分）：低于70%不变量强制执行

**检查项**：
- [ ] 在聚合根方法中强制（4分）：不变量在聚合根方法中验证
- [ ] 异常处理（3分）：违反不变量时抛出异常

**示例**：
```typescript
class Order {
  addItem(item: OrderItem): void {
    // 不变量：订单不能有 10 个以上的项目
    if (this.items.length >= 10) {
      throw new Error("Cannot add more than 10 items")
    }
    // 不变量：订单项价格不能为负
    if (item.price.isNegative()) {
      throw new Error("Item price cannot be negative")
    }
    this.items.push(item)
    this.recalculateTotal()
  }
}
```

**扣分项**：
- 未在聚合根中强制：不变量在应用层强制扣 3 分/处
- 无异常处理：违反不变量未抛出异常扣 2 分/处

---

### 4.3 不变量分类（3 分）

**满分**：3 分

**评分标准**：
- 优秀（90-100分）：所有不变量都已正确分类
- 良好（80-89分）：90%以上不变量正确分类
- 及格（60-79分）：70%以上不变量正确分类
- 不及格（<60分）：低于70%不变量正确分类

**检查项**：
- [ ] 分类完整（3分）：不变量分为状态约束、数量约束、值约束、引用约束

**扣分项**：
- 分类错误：不变量分类错误扣 1 分/个

---

## 快速评分表

| 检查项 | 分值 | 得分 | 备注 |
|--------|------|------|------|
| **聚合根识别** | | | |
| 有全局唯一标识 | 2 | __ | 聚合根判断 |
| 维护一致性边界 | 3 | __ | 聚合根判断 |
| 拥有独立生命周期 | 2 | __ | 聚合根判断 |
| 是外部访问唯一入口 | 3 | __ | 聚合根判断 |
| 标识区分 | 3 | __ | 聚合根vs实体 |
| 访问方式 | 3 | __ | 聚合根vs实体 |
| 生命周期 | 2 | __ | 聚合根vs实体 |
| 仓储 | 2 | __ | 聚合根vs实体 |
| 使用业务语言 | 3 | __ | 聚合根命名 |
| 语义明确 | 2 | __ | 聚合根命名 |
| **聚合边界设计** | | | |
| 聚合大小合理 | 7 | __ | 1-3实体，深度1-2层 |
| 聚合根唯一入口 | 3 | __ | 只能通过聚合根访问 |
| 聚合内强一致 | 5 | __ | 同一事务修改 |
| 聚合间最终一致 | 5 | __ | 通过领域事件 |
| 只存储 ID | 7 | __ | 不存储对象引用 |
| ID 类型正确 | 3 | __ | 类型化 ID |
| 事务边界正确 | 5 | __ | 一事务一聚合 |
| **实体与值对象** | | | |
| 有唯一标识(ID) | 2 | __ | 实体识别 |
| 需要追踪状态变化 | 3 | __ | 实体识别 |
| 属性变仍是同一 | 2 | __ | 实体识别 |
| 需要独立存储/检索 | 3 | __ | 实体识别 |
| 只关注属性值 | 2 | __ | 值对象识别 |
| 属性相同可互换 | 3 | __ | 值对象识别 |
| 不可变 | 3 | __ | 值对象识别 |
| 生命周期依附他人 | 2 | __ | 值对象识别 |
| 判断标准明确 | 3 | __ | 实体vs值对象 |
| 实际应用 | 2 | __ | 实体vs值对象 |
| **聚合不变量** | | | |
| 状态约束 | 1 | __ | 不变量识别 |
| 数量约束 | 2 | __ | 不变量识别 |
| 值约束 | 1 | __ | 不变量识别 |
| 引用约束 | 1 | __ | 不变量识别 |
| 聚合根方法中强制 | 4 | __ | 不变量实现 |
| 异常处理 | 3 | __ | 不变量实现 |
| 分类完整 | 3 | __ | 不变量分类 |
| **总计** | 100 | __ | |

---

## 及格标准

- **章节及格线**：60 分
- **优秀线**：80 分
- **核心项必须通过**：
  - 聚合根判断 ≥ 7 分
  - 聚合大小合理 ≥ 5 分
  - 聚合内强一致 ≥ 4 分
  - 只存储 ID ≥ 5 分
  - 值对象不可变 ≥ 3 分

---

## 评分示例

### 优秀示例（92 分）

**场景**：订单聚合设计

**评分过程**：
1. 聚合根识别：24/25 分
   - 四问法判断：10/10 分（Order 通过所有四问）
   - 聚合根vs实体：9/10 分（正确区分，扣1分因为 OrderItem 访问方式描述不够清晰）
   - 聚合根命名：5/5 分（Order 命名清晰）

2. 聚合边界设计：32/35 分
   - 黄金法则：9/10 分（Order 聚合有 OrderItem，大小合理，扣1分因为 OrderItem 有 2 个子实体深度略深）
   - 强一致性边界：10/10 分（聚合内强一致，聚合间最终一致）
   - 聚合间引用：9/10 分（Order 只存储 userId，扣1分因为使用原始类型 string 而非 UserId）
   - 一个事务一个聚合：4/5 分（基本遵循，扣1分因为有一处跨聚合事务）

3. 实体与值对象：23/25 分
   - 实体识别：9/10 分（OrderItem 和 ShippingInfo 都正确识别，扣1分因为 ShippingInfo 生命周期描述不够清晰）
   - 值对象识别：9/10 分（Money 不可变，扣1分因为 Address 的不可变性说明不够充分）
   - 实体vs值对象：5/5 分（判断标准明确，应用一致）

4. 聚合不变量：13/15 分
   - 不变量识别：5/5 分（状态、数量、值、引用约束都已识别）
   - 不变量实现：6/7 分（在聚合根方法中强制，扣1分因为有一处异常处理不够完善）
   - 不变量分类：2/3 分（基本正确，扣1分因为有一个约束分类有误）

**总分**：92/100 分（优秀）

**改进建议**：
1. 优化 OrderItem 的访问方式描述
2. 减少聚合深度到 2 层以内
3. 使用类型化 ID（UserId）
4. 避免跨聚合事务
5. 完善 ShippingInfo 的生命周期说明
6. 完善 Address 的不可变性说明
7. 完善异常处理
8. 修正约束分类

---

## 原则追溯

本评分标准基于以下原则：
- aggregate.md 1.1-1.3：聚合根识别原则
- aggregate.md 2.1-2.6：聚合设计核心原则
- aggregate.md 3.1-3.3：聚合边界确定原则
- aggregate.md 4.1-4.2：实体识别原则
- aggregate.md 5.1-5.2：值对象识别原则
- aggregate.md 6.1-6.3：聚合不变量原则
- aggregate.md 7.1-7.3：聚合设计模式

---

## 检查清单对应

本评分标准与 chapter-02-checklist.md 对应：
- 聚合根识别 → 检查清单第 1 节
- 聚合边界设计 → 检查清单第 2-3 节
- 实体与值对象 → 检查清单第 4-5 节
- 聚合不变量 → 检查清单第 2 节（不变量）
