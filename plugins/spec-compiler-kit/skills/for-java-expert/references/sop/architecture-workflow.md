# 架构设计工作流

## 概述

本文档描述 Java DDD 架构设计的标准作业流程，包括需求分析、领域建模、数据库设计和代码实现。

---

## 阶段 1：需求分析

### 1.1 理解业务

**目标**：与业务沟通，确定通用语言

**输出**：
- 业务术语定义
- 业务流程图
- 用例列表

**检查清单**：
- [ ] 是否与业务确认了术语定义？
- [ ] 是否绘制了业务流程图？
- [ ] 是否列出了所有用例？

### 1.2 确定范围

**目标**：识别核心域、支撑域、通用域

**输出**：
- 域分类列表
- 优先级排序

**检查清单**：
- [ ] 是否识别了核心域？
- [ ] 是否确定了域边界？
- [ ] 是否排除了通用域（使用现成方案）？

### 1.3 评估风险

**目标**：识别技术风险和业务风险

**输出**：
- 风险列表
- 风险应对方案

**检查清单**：
- [ ] 是否识别了性能风险？
- [ ] 是否识别了安全风险？
- [ ] 是否识别了数据一致性风险？

---

## 阶段 2：领域建模

### 2.1 识别限界上下文

**目标**：划分业务边界

**输出**：
- 上下文图
- 上下文映射关系

**示例**：
```
电商系统
├── 订单上下文 (Order Context)
├── 支付上下文 (Payment Context)
├── 库存上下文 (Inventory Context)
└── 用户上下文 (User Context)
```

**检查清单**：
- [ ] 上下文边界是否清晰？
- [ ] 是否有明确的上下文间通信方式？
- [ ] 是否避免了共享数据模型？

### 2.2 识别聚合

**目标**：设计聚合根和聚合边界

**输出**：
- 聚合列表
- 聚合关系图

**示例**：
```
订单聚合 (Order Aggregate)
├── Order (聚合根)
└── OrderItem (聚合内对象)

用户聚合 (User Aggregate)
└── User (聚合根)
```

**检查清单**：
- [ ] 每个聚合是否有明确的聚合根？
- [ ] 聚合边界是否合理？
- [ ] 是否通过 ID 引用其他聚合？

### 2.3 识别实体和值对象

**目标**：区分实体和值对象

**输出**：
- 实体列表
- 值对象列表

**检查清单**：
- [ ] 实体是否有唯一标识？
- [ ] 值对象是否不可变？
- [ ] 是否使用了值对象表达业务概念？

### 2.4 定义领域服务

**目标**：识别跨聚合的业务逻辑

**输出**：
- 领域服务列表

**检查清单**：
- [ ] 领域服务是否无状态？
- [ ] 领域服务是否不依赖 Repository？
- [ ] 是否将纯计算放在 Domain 层？

---

## 阶段 3：数据库设计

### 3.1 选择分片策略

**目标**：确定分库分表方案

**输出**：
- 分片键选择
- 分片规则

**检查清单**：
- [ ] 是否选择了合适的分片键？
- [ ] 是否避免了跨分片查询？
- [ ] 是否考虑了数据迁移？

### 3.2 设计表结构

**目标**：设计数据库表

**输出**：
- 表结构 DDL
- 索引设计

**规范**：
- 使用双软删除
- DATETIME(3) 精度
- VARCHAR(64) 长度

**检查清单**：
- [ ] 表结构是否符合 DDD 聚合？
- [ ] 是否有必要的索引？
- [ ] 是否遵循了命名规范？

---

## 阶段 4：代码实现

### 4.1 实现 Domain 层

**目标**：实现实体、值对象、领域服务

**规范**：
- Entity 包含业务逻辑（充血模型）
- Value Object 不可变
- Domain Service 无状态，不依赖 Repository

**检查清单**：
- [ ] Domain 层是否不依赖 Repository？
- [ ] 业务规则是否在 Domain 层？
- [ ] 是否使用了值对象？

### 4.2 实现 Application 层

**目标**：实现业务编排、数据访问、事务管理

**规范**：
- 定义 Application 接口
- 实现 Application Impl
- 使用 @Transactional 管理事务

**检查清单**：
- [ ] 是否定义了 Application 接口？
- [ ] 数据查询是否在 Application 层？
- [ ] 是否正确使用 @Transactional？

### 4.3 实现 Controller 层

**目标**：实现 REST API

**规范**：
- 只使用 POST 请求
- 参数封装成 XxxParam
- 返回 ApiResponse<XxxDTO>

**检查清单**：
- [ ] 是否只使用 POST 请求？
- [ ] 参数是否封装？
- [ ] 是否统一返回 ApiResponse？

### 4.4 实现 Repository 层

**目标**：实现数据访问

**规范**：
- 定义 Repository 接口
- 实现 Repository Impl
- 使用 MyBatis Mapper

**检查清单**：
- [ ] 是否定义了 Repository 接口？
- [ ] 是否使用了 MyBatis？
- [ ] 是否有正确的 DTO 转换？

---

## 阶段 5：测试

### 5.1 单元测试

**目标**：测试业务逻辑

**覆盖率**：≥ 80%

**检查清单**：
- [ ] Domain 层是否有单元测试？
- [ ] Application 层是否有单元测试？
- [ ] 是否覆盖了所有用例？

### 5.2 集成测试

**目标**：测试端到端流程

**检查清单**：
- [ ] 是否有集成测试？
- [ ] 是否测试了关键流程？
- [ ] 是否测试了异常情况？

---

## 输出检查清单

### 架构设计
- [ ] 是否清晰识别了限界上下文？
- [ ] 是否设计了合理的聚合边界？
- [ ] 分层架构是否清晰？
- [ ] 依赖方向是否正确？

### 编码规范
- [ ] **SOLID**: 每个类职责是否单一？
- [ ] **DRY**: 是否有重复代码？
- [ ] **KISS**: 代码是否过度复杂？
- [ ] **YAGNI**: 是否为未来需求过度设计？

### 性能
- [ ] 时间复杂度是否最优？
- [ ] 是否有 N+1 查询？
- [ ] 是否有不必要的数据库查询？

### 安全
- [ ] 输入是否都经过验证？
- [ ] SQL 注入风险是否排除？
- [ ] 敏感数据是否加密？
