---
description: 限界上下文详解
---

# 限界上下文详解

## 概述

限界上下文（Bounded Context）是 DDD 中最重要的战略设计概念之一。它定义了特定领域模型的适用范围，是一个明确的边界，边界内部术语一致，概念明确。

## 核心概念

### 定义

> 限界上下文是一个特定的边界，边界内部特定领域模型的所有术语、概念和规则是一致的。

### 特征

| 特征 | 说明 |
|------|------|
| **语言一致性** | 边界内部使用统一的术语 |
| **概念明确** | 每个概念有明确的定义 |
| **边界清晰** | 边界不重叠，职责单一 |
| **可独立部署** | 可以独立部署和演进 |
| **团队对齐** | 通常对应一个团队 |

## 为什么需要限界上下文

### 问题 1: 术语混乱

```
问题：同一个词在不同上下文含义不同

示例：
- "会员"在会员上下文 = 订阅关系
- "会员"在用户上下文 = 用户属性
- "会员"在支付上下文 = 折扣标识

解决方案：限界上下文明确边界，每个上下文有自己的术语定义
```

### 问题 2: 模型混乱

```
问题：大型系统中模型变得复杂混乱

原因：
- 不同部分的需求不同
- 不同团队的实现不同
- 系统演进过程中的技术债

解决方案：限界上下文分割，每个上下文有独立的模型
```

### 问题 3: 变更困难

```
问题：一个小改动影响整个系统

原因：
- 缺少边界，牵一发而动全身
- 耦合严重，修改风险高

解决方案：限界上下文明确边界，变更局限在上下文内
```

## 限界上下文的类型

### 核心域（Core Domain）

**特征**：
- 竞争力所在
- 业务差异化
- 高投入产出

**投入策略**：
- 80% 精力
- 最优秀的团队
- 持续优化

**示例**：
- 电商的推荐算法
- 金融的风控系统
- 订阅制平台的会员体系

### 支撑域（Supporting Domain）

**特征**：
- 必要但非差异化
- 直接支持业务
- 但不是核心竞争力

**投入策略**：
- 够用就好
- 避免过度设计
- 可以考虑采购

**示例**：
- 用户管理系统
- 通知系统
- 报表系统

### 通用域（Generic Domain）

**特征**：
- 标准功能
- 无特殊规则
- 可直接采购

**投入策略**：
- 直接购买
- 使用开源方案
- 最小化定制

**示例**：
- 支付网关
- 短信服务
- 文件存储
- 身份认证

### 泛化域（Generic Domain）

**特征**：
- 无特殊规则
- 到处都一样
- 几乎不需要业务定制

**投入策略**：
- 最小投入
- 使用最简单方案

**示例**：
- 日志系统
- 监控系统
- 配置管理
- 权限框架

## 限界上下文划分方法

### 方法 1: 按业务能力划分

```
业务能力 → 限界上下文

示例：
- 会员订阅能力 → 会员上下文
- 点券发放能力 → 点券上下文
- 支付处理能力 → 支付上下文
```

### 方法 2: 按组织结构对齐

```
团队结构 → 限界上下文

遵循康威定律：
- 一个上下文对应一个团队
- 团队沟通模式 = 上下文集成模式

示例：
- 会员组 → 会员上下文
- 支付组 → 支付上下文
```

### 方法 3: 按数据所有权划分

```
数据所有权 → 限界上下文

原则：
- 一个数据只有一个所有者
- 其他上下文通过 ID 引用

示例：
- 会员数据 → 会员上下文
- 点券数据 → 点券上下文
- 用户数据 → 用户上下文
```

### 方法 4: 按实时性要求划分

```
实时性要求 → 限界上下文

高实时性 → 同步集成
低实时性 → 异步集成

示例：
- 库存扣减（高实时性） → 库存上下文
- 数据分析（低实时性） → 分析上下文
```

## 限界上下文设计

### 设计流程

```
1. 识别业务能力
   └─ 从 PRD 提取能力动词

2. 能力分组
   └─ 按相关性分组能力

3. 确定边界
   └─ 确定上下文职责和边界

4. 定义类型
   └─ 确定是核心/支撑/通用/泛化

5. 上下文映射
   └─ 定义上下文间关系

6. 团队对齐
   └─ 确保团队与上下文对齐
```

### 设计原则

| 原则 | 说明 |
|------|------|
| **职责单一** | 一个上下文只做一件事 |
| **语言一致** | 边界内术语统一 |
| **边界清晰** | 边界不重叠 |
| **独立演进** | 可独立部署和修改 |
| **团队对齐** | 与组织结构对齐 |

## 限界上下文示例

### 示例 1: 会员订阅系统

```markdown
## 限界上下文划分

### 会员上下文
- 职责：管理会员订阅生命周期
- 类型：核心域
- 核心概念：会员、订阅、等级

### 点券上下文
- 职责：管理点券发放和消费
- 类型：核心域
- 核心概念：点券、发放记录、消费记录

### 支付上下文
- 职责：处理支付
- 类型：通用域
- 核心概念：支付、退款、对账

### 用户上下文
- 职责：管理用户账号
- 类型：支撑域
- 核心概念：用户、账号、认证
```

### 示例 2: 电商平台

```markdown
## 限界上下文划分

### 商品上下文
- 职责：商品目录管理
- 类型：支撑域
- 核心概念：商品、分类、库存

### 订单上下文
- 职责：订单处理
- 类型：核心域
- 核心概念：订单、订单项、订单状态

### 支付上下文
- 职责：支付处理
- 类型：通用域
- 核心概念：支付、支付方式

### 物流上下文
- 职责：物流配送
- 类型：支撑域
- 核心概念：发货、配送、物流单

### 营销上下文
- 职责：营销活动
- 类型：核心域
- 核心概念：活动、优惠券、折扣

### 用户上下文
- 职责：用户管理
- 类型：支撑域
- 核心概念：用户、账号、权限
```

## 限界上下文和微服务

### 关系

```
限界上下文 ≠ 微服务

关系：
- 限界上下文是逻辑边界
- 微服务是物理边界
- 一个上下文可能对应一个或多个微服务
- 多个微服务可能组成一个上下文
```

### 映射策略

| 上下文复杂度 | 微服务策略 |
|--------------|------------|
| 简单 | 一个上下文 = 一个微服务 |
| 中等 | 一个上下文 = 多个微服务 |
| 复杂 | 多个上下文 = 一个微服务 |

### 拆分时机

```
何时拆分为多个微服务？

1. 需要独立扩展
   - 订单查询量 >> 订单创建量
   → 拆分为订单写入服务和订单查询服务

2. 需要独立部署
   - 营销活动频繁变更
   → 拆分为独立的营销服务

3. 需要不同技术栈
   - 数据分析需要大数据技术
   → 拆分为独立的分析服务
```

## 限界上下文演进

### 演进阶段

```
阶段 1: 单体应用
└─ 所有限界上下文在一个应用中

阶段 2: 模块化单体
└─ 限界上下文作为模块分离

阶段 3: 服务化
└─ 限界上下文独立部署

阶段 4: 微服务
└─ 每个上下文可能拆分为多个服务
```

### 演进原则

| 原则 | 说明 |
|------|------|
| **渐进演进** | 不要一开始就微服务 |
| **先模块化** | 先从模块化开始 |
| **按需拆分** | 有需要时再拆分 |
| **保持简单** | 避免过度设计 |

## 常见错误

### 错误 1: 上下文太大

```
问题：一个上下文包含太多功能

症状：
- 上下文职责不清晰
- 变更影响范围大
- 难以维护

解决方案：
1. 分析上下文职责
2. 按职责拆分
3. 明确边界
```

### 错误 2: 上下文太小

```
问题：上下文过于碎片化

症状：
- 上下文数量过多
- 集成复杂
- 维护成本高

解决方案：
1. 合并相关上下文
2. 减少集成复杂度
3. 保持合理粒度
```

### 错误 3: 上下文边界不清

```
问题：不清楚某个概念属于哪个上下文

症状：
- 概念归属模糊
- 术语不统一
- 模型混乱

解决方案：
1. 明确各上下文职责
2. 定义术语表
3. 建立上下文图
```

## 参考资料

- Domain-Driven Design (Eric Evans) - Chapter 14
- Strategic Domain-Driven Design (Vaughn Vernon)
- Bounded Contexts (Martin Fowler)
