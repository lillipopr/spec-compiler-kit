# {功能名称} - 领域设计文档

> **文档版本**：v1.0
> **创建时间**：{YYYY-MM-DD}

---

## 文档说明

本文档是领域架构师的核心产出物，整合了战略设计、战术设计、约束定义和用例设计四个部分。

### 核心原则

- **理论依据**：所有设计都有明确的理论支撑（DDD、状态机理论、不变量理论）
- **最佳实践**：符合业内公认的设计模式和规范
- **跨端一致性**：第三、四部分的内容在所有端保持一致
- **可验证性**：每个约束都可写成 assert，每个用例都可转化为测试

### 适用范围

本文档适用于以下架构类型：
- [ ] DDD 分层架构 Application → Domain → Infra
---

## 第一部分：战略设计

> **目标**：识别业务核心能力，划分限界上下文，定义上下文间关系。

### 1. 业务能力分析

#### 1.1 业务能力树

```
{业务领域}
├── {一级能力1}
│   ├── {二级能力1.1}
│   └── {二级能力1.2}
└── {一级能力2}
    ├── {二级能力2.1}
    └── {二级能力2.2}
```

#### 1.2 能力分级

| 能力 | 类型 | 说明 | 战略重要性 |
|------|------|------|-----------|
| {能力1} | 核心域 | 差异化竞争力 | 高 |
| {能力2} | 支撑域 | 必要但非差异化 | 中 |
| {能力3} | 通用域 | 可外包/复用 | 低 |

#### 1.3 能力与团队对齐

| 能力 | 负责团队 | 上下游关系 |
|------|---------|-----------|
| {能力1} | {团队A} | 上游：{能力X}，下游：{能力Y} |

---

### 2. 限界上下文划分

#### 2.1 上下文识别

| 上下文名称 | 负责的业务能力 | 核心实体 | 上下文类型 |
|-----------|---------------|---------|-----------|
| {上下文1} | {能力描述} | {实体1}, {实体2} | 核心域 |
| {上下文2} | {能力描述} | {实体3}, {实体4} | 支撑域 |

#### 2.2 上下文边界

```
┌─────────────────────────────────────────────────────────────┐
│                        {系统名称}                             │
├─────────────────────┬─────────────────────┬─────────────────┤
│   {上下文1}         │   {上下文2}         │   {上下文3}     │
│   (核心域)          │   (支撑域)          │   (通用域)      │
├─────────────────────┼─────────────────────┼─────────────────┤
│ 核心实体:          │ 核心实体:          │ 核心实体:      │
│ - {实体1}          │ - {实体3}          │ - {实体5}      │
│ - {实体2}          │ - {实体4}          │ - {实体6}      │
└─────────────────────┴─────────────────────┴─────────────────┘
```

---

### 3. 上下文映射

#### 3.1 上下文关系图

```
{上下文A} ←→ {上下文B}
   ↑            ↑
   │            │
   └──→ {上下文C}
```

#### 3.2 集成模式定义

| 上游 | 下游 | 关系类型 | 集成模式 | 说明 |
|------|------|---------|---------|------|
| {上下文A} | {上下文B} | 上游下游 | O/C（上游/下游） | A 的变化影响 B |
| {上下文B} | {上下文C} | 独立 | ACL（防腐层） | C 通过防腐层调用 B |

#### 3.3 防腐层设计

| 防腐层位置 | 目标上下文 | 转换逻辑 |
|-----------|-----------|---------|
| {位置} | {上下文C} | 将 C 的 DTO 转换为本域的领域模型 |

---

## 第二部分：战术设计（统一建模）

> **目标**：在限界上下文内进行聚合设计，定义领域模型结构。

### 1. 聚合设计

#### 1.1 聚合识别

| 聚合名称 | 聚合根 | 聚合边界 | 一致性保证 |
|---------|--------|---------|-----------|
| {聚合1} | {聚合根实体} | 包含的实体/值对象 | {不变量描述} |

#### 1.2 聚合图

```
{聚合根}
├── {实体1}（实体）
│   └── {值对象1}（值对象）
└── {实体2}（实体）
```

#### 1.3 聚合间引用

| 聚合 | 引用方式 | 目标聚合 | 引用类型 |
|------|---------|---------|---------|
| {聚合A} | ID 引用 | {聚合B} | 直接引用 |
| {聚合C} | 领域事件 | {聚合D} | 事件驱动 |

---

### 2. 聚合根、实体、值对象

#### 2.1 聚合根列表

| 聚合根名称 | 唯一标识 | 生命周期 | 状态 | 承载的不变量 |
|-----------|---------|---------|------|-------------|
| {聚合根1} | {id字段} | {创建→...→终结} | {状态列表} | {不变量1}, {不变量2} |

#### 2.2 实体列表

| 实体名称 | 唯一标识 | 生命周期 | 状态 | 所属聚合 |
|---------|---------|---------|------|---------|
| {实体1} | {id字段} | {创建→...→终结} | {状态列表} | {聚合根} |

#### 2.3 值对象列表

| 值对象名称 | 所属实体 | 说明 | 不变性 |
|-----------|---------|------|--------|
| {值对象1} | {实体} | {说明} | 不可替换 |

#### 2.4 实体 vs 值对象判断依据

每个实体必须满足三个必要条件：
- [ ] **唯一标识**：即使属性改变，业务上还是"同一个"
- [ ] **生命周期**：有创建、变化、终结的过程
- [ ] **状态转移**：业务需要追踪其状态变化

---

### 3. 领域事件

#### 3.1 事件列表

| 事件名称 | 触发条件 | 携带数据 | 订阅方 |
|---------|---------|---------|--------|
| {事件1} | {条件描述} | {数据结构} | {订阅方1}, {订阅方2} |

#### 3.2 事件定义模板

```
事件名称：{事件名称}
触发聚合：{聚合根}
触发条件：{条件}
携带数据：
  - {字段1}: {类型}
  - {字段2}: {类型}
订阅方：
  - {订阅方1}: {处理逻辑}
  - {订阅方2}: {处理逻辑}
```

---

### 4. 领域服务

#### 4.1 领域服务识别

领域服务的判断标准：
- 涉及多个聚合根的协作
- 不属于任何特定实体的行为
- 需要访问领域外服务

#### 4.2 领域服务列表

| 服务名称 | 职责 | 涉及的聚合 | 依赖 |
|---------|------|-----------|------|
| {服务1} | {职责描述} | {聚合A}, {聚合B} | {外部依赖} |

---

### 5. 仓储接口

#### 5.1 仓储定义

每个聚合根对应一个仓储接口。

#### 5.2 仓储接口列表

| 仓储名称 | 聚合根 | 核心方法 |
|---------|--------|---------|
| {仓储1} | {聚合根} | findById, save, delete, findBy{条件} |

#### 5.3 仓储接口定义模板

```typescript
interface {聚合根}Repository {
  findById(id: {ID类型}): Promise<{聚合根} | null>
  save(aggregate: {聚合根}): Promise<void>
  delete(id: {ID类型}): Promise<void>
  // 自定义查询方法
  findBy{条件}(params: {参数类型}): Promise<{聚合根}[]>
}
```

---

### 6. 应用层接口：行为列表

> **关键区分**：行为分为用户行为（应用层意图）和系统行为（领域层事实）

#### 6.1 用户行为（应用层意图）

| 行为名称 | 触发方 | 描述 | 影响的聚合 | 应用服务 |
|---------|--------|------|-----------|---------|
| {行为1} | 用户 | {描述} | {聚合} | {应用服务} |
| {行为2} | 外部系统 | {描述} | {聚合} | {应用服务} |

#### 6.2 系统行为（领域层事实）

| 行为名称 | 触发方式 | 描述 | 影响的聚合 | 实现方式 |
|---------|---------|------|-----------|---------|
| {行为1} | 定时任务 | {描述} | {聚合} | {定时器/事件} |
| {行为2} | 事件监听 | {描述} | {聚合} | {事件处理器} |

#### 6.3 应用层接口定义模板

```typescript
interface {功能}AppService {
  // 用户行为
  {用户行为}(request: {Request}): Promise<{Response}>

  // 系统行为（如需要暴露）
  {系统行为}(params: {Params}): Promise<Result>
}
```

---

## 第三部分：约束定义

> **跨端一致性声明**：本部分的约束定义适用于所有端（后端/iOS/前端）。
> 各端实现时将伪代码翻译为对应语言，但约束语义必须保持一致。

### 1. 状态定义表

#### 1.1 {实体1} 状态定义

| 状态码 | 状态名称 | 含义 | 可转移状态 |
|-------|---------|------|-----------|
| S0 | {状态名} | {含义} | S1, S9 |
| S1 | {状态名} | {含义} | S2 |

**状态设计原则**：
- [ ] 状态互斥（同一时刻只能处于一个状态）
- [ ] 状态完备（覆盖所有可能情况）
- [ ] 无孤岛状态（每个状态可达可离）

---

### 2. 状态转移表

#### 2.1 {实体1} 状态转移

| 当前状态 | 触发行为 | 行为类型 | 目标状态 | 约束条件 |
|---------|---------|---------|---------|---------|
| S0 | {行为} | 用户/系统 | S1 | {条件} |
| S1 | {行为} | 用户/系统 | S2 | {条件} |

#### 2.2 状态转移伪代码

```
ALLOWED_TRANSITIONS = {
    # (当前状态, 事件) -> (下一状态, [约束列表])
    ("S0", "event_a"): ("S1", [INV-01, INV-02]),
    ("S1", "event_b"): ("S2", [INV-01]),
}

FUNCTION validate_state_transition(current_state, event, next_state) -> bool
    key = (current_state, event)
    ASSERT key IN ALLOWED_TRANSITIONS
    ON_VIOLATION: THROW "STA-01: 未定义的状态转移"

    expected_state, constraints = ALLOWED_TRANSITIONS[key]
    ASSERT next_state == expected_state
    ON_VIOLATION: THROW "STA-02: 状态转移目标错误"

    FOR EACH constraint IN constraints
        constraint.validate()
    END FOR

    RETURN true
END FUNCTION
```

---

### 3. 不变量清单

> **不变量三测试**：每个不变量必须满足可执行、可测试、可解释。

#### 3.1 结构约束

| 约束ID | 约束描述 | 伪代码 | 执行时机 |
|-------|---------|-------|---------|
| STR-01 | {描述} | `ASSERT {条件}` | 创建/更新时 |

#### 3.2 业务约束

| 约束ID | 约束描述 | 伪代码 | 执行时机 |
|-------|---------|-------|---------|
| BIZ-01 | {描述} | `ASSERT {条件}` | 操作时 |

#### 3.3 状态约束

| 约束ID | 约束描述 | 伪代码 | 执行时机 |
|-------|---------|-------|---------|
| STA-01 | {描述} | `ASSERT {条件}` | 状态变更时 |

#### 3.4 版本约束

| 约束ID | 约束描述 | 伪代码 | 执行时机 |
|-------|---------|-------|---------|
| VER-01 | {描述} | `ASSERT {条件}` | 修改时 |

#### 3.5 不变量定义模板

```
### INV-XX: {约束名称}

**约束描述**：{一句话描述}

**理论依据**：{理论来源，如 DDD 聚合设计原则}

**伪代码**：
```
FUNCTION validate_{constraint_name}(entity) -> bool
    ASSERT {条件表达式}
    ON_VIOLATION: THROW "INV-XX: {错误信息}"
    RETURN true
END FUNCTION
```

**各端实现位置**：
| 端 | 层级 | 文件 | 方法 |
|----|------|------|------|
| 后端 | Domain | XxxDomain.java | validateXxx() |
| iOS | Service | XxxService.swift | validateXxx() |
| 前端 | Service | xxxService.ts | validateXxx() |
```

---

### 4. 禁止态说明

#### 4.1 禁止态列表

- **禁止态-1**：{描述}
- **禁止态-2**：{描述}

#### 4.2 禁止态伪代码

```
PROHIBITED_TRANSITIONS = {
    # (当前状态, 目标状态) -> "禁止原因"
    ("S2", "S0"): "已发货订单不能回退到待支付",
}

FUNCTION validate_not_prohibited(current_state, next_state) -> bool
    key = (current_state, next_state)
    ASSERT key NOT IN PROHIBITED_TRANSITIONS
    ON_VIOLATION: THROW "STA-03: 禁止的状态转移, reason={PROHIBITED_TRANSITIONS[key]}"
    RETURN true
END FUNCTION
```

---

### 5. 约束执行时机表

| 约束ID | 执行时机 | 执行位置 | 失败处理 |
|-------|---------|---------|---------|
| STR-01 | 实体创建时 | Domain 层 | 抛出异常，拒绝操作 |
| BIZ-01 | 业务操作前 | Application 层 | 返回错误信息 |
| STA-01 | 状态变更时 | Domain 层 | 抛出异常，回滚状态 |

---

### 6. 约束违反处理策略

#### 6.1 约束优先级

| 优先级 | 描述 | 处理策略 | 示例 |
|-------|------|----------|------|
| **P0** | 数据一致性破坏 | 立即抛异常，回滚事务 | 库存为负 |
| **P1** | 业务规则违反 | 阻止操作，返回错误 | 非会员发点券 |
| **P2** | 数据完整性问题 | 记录警告，允许操作 | 非必填字段为空 |
| **P3** | 可解释性问题 | 记录日志，人工审核 | 计算结果异常 |

#### 6.2 处理策略表

| 约束ID | 优先级 | 违反处理 | 恢复方式 |
|-------|--------|---------|---------|
| INV-01 | P0 | 抛出异常，回滚事务 | 修复输入后重试 |
| INV-02 | P1 | 返回错误信息 | 调整参数后重试 |

---

## 第四部分：用例设计

> **跨端一致性声明**：本部分的用例适用于所有端。
> 各端测试时使用相同的用例数据和预期结果。

### 1. 正向用例（Happy Path）

#### Case-01: {用例名称}

**前置条件（Given）**：
- 系统状态：{状态描述}
- 数据状态：{数据描述}
- 外部依赖状态：{依赖描述}

**触发行为（When）**：
- {用户/系统做了什么}

**预期结果（Then）**：
- 状态变化：{变化描述}
- 输出结果：{输出描述}
- 副作用：{日志、消息、调用}

**约束/不变量**：
- INV-01: {约束描述}
- INV-02: {约束描述}

**各端验证方式**：
| 端 | 验证方式 | 测试文件 |
|----|---------|---------|
| 后端 | 单元测试 / 集成测试 | XxxTest.java |
| iOS | 单元测试 / UI 测试 | XxxTests.swift |
| 前端 | 单元测试 / E2E 测试 | xxx.test.ts |

---

### 2. Bad Case（禁止态验证）

#### Case-B1: {用例名称}

**前置条件（Given）**：
- {状态描述}

**触发行为（When）**：
- {触发描述}

**预期结果（Then）**：
- 状态变化：无（或状态回滚）
- 输出结果：拒绝操作，返回错误 "{错误信息}"
- 副作用：无

**约束/不变量**：
- {违反的不变量ID}: {约束描述}

---

### 3. 边界用例

#### Case-E1: {用例名称}

**前置条件（Given）**：
- {边界条件描述，如库存=0，金额=最大值}

**触发行为（When）**：
- {操作描述}

**预期结果（Then）**：
- {结果描述}

---

### 4. 用例覆盖矩阵

| 用例ID | 类型 | 覆盖不变量 | 覆盖状态转移 | 优先级 |
|--------|------|------------|--------------|--------|
| Case-01 | 正向 | INV-01, INV-02 | S0→S1 | P0 |
| Case-B1 | Bad | INV-01 | 禁止态 | P0 |
| Case-E1 | 边界 | INV-02 | S1→S2 | P1 |

**覆盖完整性检查**：
- [ ] 所有不变量至少有一个用例覆盖
- [ ] 所有状态转移至少有一个用例覆盖
- [ ] 所有禁止态至少有一个 Bad Case
- [ ] P0 用例 100% 覆盖

---

### 5. 用例优先级

#### 5.1 优先级定义

| 优先级 | 定义 | 比例要求 | 示例 |
|-------|------|---------|------|
| **P0** | 核心业务流程，必须实现 | ≤ 30% | 会员订阅成功 |
| **P1** | 重要边界条件，应实现 | ≤ 40% | 库存恰好售罄 |
| **P2** | 边缘场景，可延后 | ≤ 30% | 并发创建订单 |

#### 5.2 用例优先级列表

| 用例ID | 优先级 | 实现顺序 | 依赖 |
|--------|--------|---------|------|
| Case-01 | P0 | 1 | 无 |
| Case-B1 | P0 | 2 | 无 |
| Case-E1 | P1 | 3 | Case-01 |

---

## 附录

### A. 理论依据

| 设计内容 | 理论来源 | 说明 |
|---------|---------|------|
| 聚合设计 | Eric Evans《Domain-Driven Design》 | 实体收敛原则 |
| 不变量约束 | Bertrand Meyer《面向对象软件构造》 | 设计 by contract |
| 状态机建模 | David Harel | 状态图在软件设计中的应用 |
| 约束优先级 | Michael Jackson | 问题框架方法 |

### B. 参考最佳实践

| 来源 | 应用内容 |
|------|---------|
| 《实现领域驱动设计》 | 聚合设计模式 |
| 《领域驱动设计模式》 | 战术设计模式 |
| Martin Fowler | 领域事件模式 |

### C. 各层职责速查

#### 后端 DDD 分层

| 层 | 职责 | 示例 |
|----|------|------|
| Controller | 接收请求、参数校验 | MembershipController |
| Application | 用例编排、事务管理 | MembershipAppService |
| Domain | 业务逻辑、不变量校验 | Membership (聚合根) |
| Gateway/Infra | 外部服务调用 | PaymentGateway |
| Mapper | 数据库访问 | MembershipMapper |

#### iOS MVVM 分层

| 层 | 职责 | 示例 |
|----|------|------|
| View | SwiftUI 视图、用户交互 | MembershipView |
| ViewModel | 状态管理、业务编排 | MembershipViewModel |
| Service | 业务逻辑、数据转换 | MembershipService |
| Gateway | HTTP 请求、响应解析 | MembershipAPI |
| Network | 请求封装、拦截器 | MembershipAPI |

#### Vue 3 前端分层

| 层 | 职责 | 示例 |
|----|------|------|
| View | Vue 组件、模板、样式 | MembershipView.vue |
| Composable | 状态管理、业务编排 | useMembership.ts |
| Service | 业务逻辑、数据转换 | membershipService.ts |
| API | 接口路径、参数组装 | membershipApi.ts |
| Request | axios 封装、拦截器 | request.ts |

### D. 设计原则检查清单

#### 战略设计检查

- [ ] 业务能力分析完整
- [ ] 限界上下文划分合理
- [ ] 上下文映射关系明确
- [ ] 核心域/支撑域/通用域识别正确

#### 战术设计检查

- [ ] 聚合边界合理
- [ ] 实体与值对象区分正确
- [ ] 领域事件定义完整
- [ ] 领域服务职责清晰
- [ ] 仓储接口定义合理

#### 约束定义检查

- [ ] 所有状态定义完备且互斥
- [ ] 状态转移表无遗漏
- [ ] 不变量满足三测试（可执行、可测试、可解释）
- [ ] 禁止态全部定义
- [ ] 约束执行时机明确

#### 用例设计检查

- [ ] 正向用例覆盖核心 Happy Path
- [ ] Bad Case 覆盖所有禁止态
- [ ] 边界用例覆盖临界条件
- [ ] 用例覆盖矩阵完整
- [ ] 优先级分配合理

---

**文档结束**
