# 上下文优化策略

> **目标**：在处理大型 PRD 和生成复杂领域设计文档时，避免上下文被撑爆

---

## 问题分析

### 上下文消耗来源

| 阶段 | 消耗来源 | 估算 Tokens |
|------|---------|------------|
| **输入** | PRD 文档 | 5,000 - 20,000 |
| **指令** | 章节指令 + 原则文档 | 3,000 - 5,000 |
| **生成** | 每章生成内容 | 2,000 - 5,000 |
| **累积** | 6章完整内容 | 12,000 - 30,000 |
| **总计** | 一次性处理 | 22,000 - 60,000 ❌ |

### 核心原则

1. **只保留必要信息**：不在内存中累积完整内容
2. **文件持久化**：每个章节完成后立即写入文件
3. **摘要传递**：章节间只传递关键摘要
4. **按需加载**：只在需要时加载文件内容

---

## 优化后的工作流

### 流程图

```
输入：PRD 文档（大文件）
  ↓
阶段 1：PRD 分析 + 摘要
  - 读取 PRD 文件
  - 生成 PRD 摘要文件（~500 tokens）
  - 原始 PRD 文件不再加载
  ↓
阶段 2：逐章生成（每次只处理一章）
  - 读取章节指令（~1,000 tokens）
  - 读取对应原则（~500 tokens）
  - 读取 PRD 摘要（~500 tokens）
  - 生成章节内容（~2,000 tokens）
  - 写入文件：chapter-N-output.md
  - 生成章节摘要（~200 tokens）
  - 清理章节内容，只保留摘要
  ↓
阶段 3：文档组装（只在这一步加载所有内容）
  - 读取所有章节文件
  - 使用模板组装文档
  - 写入最终文件
  - 清理所有中间内容
  ↓
输出：领域设计文档（文件路径，不返回完整内容）
```

---

## 详细实施步骤

### 阶段 1：PRD 分析与摘要

**目标**：将大型 PRD 转换为轻量级摘要

**摘要模板**：

```markdown
# PRD 摘要

## 功能概述
{2-3 句话描述功能}

## 核心实体
| 实体名 | 说明 |
|-------|------|
| {实体1} | {说明} |

## 业务流程
1. {流程1}
2. {流程2}

## 外部接口
- {接口1}

## 异步处理
- {事件1}
```

**上下文节省**：
- 原始 PRD：10,000 tokens
- PRD 摘要：500 tokens
- **节省：95%**

---

### 阶段 2：逐章生成

**核心策略**：每次只处理一章，完成后立即清理

**章节生成流程**：
```
第 N 章生成：
1. 读取章节指令
2. 读取对应原则
3. 读取 PRD 摘要
4. 读取前序章节摘要（如果有）
5. 生成章节内容
6. 写入文件（output/chapter-N.md）
7. 生成章节摘要（~200 tokens）
8. 清理章节内容
```

**章节摘要模板**：

```markdown
# 第 N 章摘要

## 章节
{章节名称}

## 关键内容
- {要点1}
- {要点2}

## 与其他章节的关系
- 依赖：{依赖的章节}
- 被依赖：{依赖此章节的章节}

## 文件路径
output/chapter-N.md
```

**上下文控制**：

| 时刻 | 上下文内容 | 估算 Tokens |
|------|-----------|------------|
| 开始 | PRD 摘要 + 章节指令 + 原则 | ~2,000 |
| 生成中 | + 章节内容 | ~4,000 |
| 完成后 | + 章节摘要 - 章节内容 | ~2,200 |

**每个章节周期**：~4,000 tokens（峰值）

---

### 阶段 3：文档组装

**目标**：只在最后一步加载所有内容

**流程**：
1. 读取所有章节文件
2. 使用模板组装
3. 写入最终文件
4. 清理中间内容

**上下文控制**：

| 时刻 | 上下文内容 | 估算 Tokens |
|------|-----------|------------|
| 开始 | 各章节摘要 + 模板 | ~3,000 |
| 加载章节 | + 6个章节文件 | ~15,000 |
| 组装完成 | + 最终文档 | ~18,000 |

**只在最后一步消耗大量上下文**

---

## 上下文对比

### 旧方案（一次性处理）

```
总上下文 = PRD + 6章指令 + 6章原则 + 6章内容 + 评分标准 + ...
         ≈ 50,000 tokens ❌
```

### 新方案（分阶段处理）

```
阶段 1：PRD 摘要
  上下文 = PRD + 指令 ≈ 5,000 tokens ✅

阶段 2：逐章生成（6次）
  每次上下文 = 摘要 + 单章指令 + 单章原则 + 单章内容 ≈ 4,000 tokens ✅

阶段 3：文档组装
  上下文 = 摘要 + 模板 + 6章文件 ≈ 18,000 tokens ✅

峰值上下文：18,000 tokens（可接受）
```

**节省：64%**

---

## 实施技巧

### 1. 使用 Write 而非 Read

**原则**：生成后立即写入文件，不要在响应中返回完整内容

```typescript
// ❌ 错误：在响应中返回完整内容
function generateChapter() {
  const content = generate()  // 2,000 tokens
  return content  // 内容会在上下文中累积
}

// ✅ 正确：写入文件，只返回摘要
function generateChapter() {
  const content = generate()  // 2,000 tokens
  writeFile("chapter-1.md", content)  // 写入文件
  return { summary: "章节摘要...", file: "chapter-1.md" }  // 只返回摘要
}
```

### 2. 文件管理策略

```
output/
├── prd-summary.md           # PRD 摘要
├── chapter-1.md             # 第一章完整内容
├── chapter-2.md             # 第二章完整内容
├── ...
├── chapter-6.md             # 第六章完整内容
├── score-report.md          # 评分报告
└── {功能名称}-领域设计文档.md # 最终文档
```

### 3. 引用而非内联

**原则**：引用文件路径，而非包含文件内容

```markdown
## 章节摘要

第一章：限界上下文设计
- 文件：output/chapter-1.md
- 关键内容：业务能力分析、上下文划分、上下文映射
```

### 4. 增量评分

**原则**：每章完成后立即评分，不要等所有章节完成

```typescript
// ✅ 正确：每章完成后评分
for (let i = 1; i <= 6; i++) {
  const chapter = generateChapter(i)
  const score = scoreChapter(chapter)
  if (score < 60) {
    regenerateChapter(i)
  }
  writeChapter(i, chapter)
  writeScore(i, score)
}

// ❌ 错误：所有章节完成后评分
const chapters = []
for (let i = 1; i <= 6; i++) {
  chapters.push(generateChapter(i))  // 累积所有内容
}
const scores = scoreAll(chapters)  // 此时上下文已满
```

---

## 特殊场景处理

### 场景 1：章节间依赖

**问题**：第二章依赖第一章的结果

**解决**：传递摘要而非完整内容

```
第一章完成：
- 生成完整内容 → 写入 chapter-1.md
- 生成摘要（包含聚合清单）
- 清理完整内容

第二章生成：
- 读取第一章摘要（获取聚合清单）
- 基于清单生成第二章
- 写入 chapter-2.md
```

### 场景 2：修改流程

**问题**：修改某个章节时需要参考其他章节

**解决**：按需加载

```
修改第 N 章：
1. 加载第 N 章内容
2. 按需加载依赖章节的摘要
3. 修改并保存
4. 重新评分第 N 章
5. 清理所有内容
```

### 场景 3：最终组装

**问题**：组装时需要加载所有章节

**解决**：只在最后一步加载

```
前 6 次迭代：
  - 只生成和保存单章
  - 不加载其他章节

第 7 次迭代：
  - 加载所有 6 个章节
  - 组装最终文档
  - 保存并清理
```

---

## 最佳实践

### DO ✅

- ✅ 每章完成后立即写入文件
- ✅ 只在上下文中保留摘要
- ✅ 按需加载文件内容
- ✅ 使用子代理隔离上下文
- ✅ 定期清理不再需要的内容

### DON'T ❌

- ❌ 在响应中返回完整章节内容
- ❌ 累积多个章节的完整内容
- ❌ 在内存中组装完整文档
- ❌ 重复加载相同内容
- ❌ 保留原始 PRD 文件

---

## 总结

### 优化效果

| 指标 | 旧方案 | 新方案 | 改善 |
|------|-------|-------|------|
| 峰值上下文 | 50,000 tokens | 18,000 tokens | ↓ 64% |
| 内存占用 | 持续高 | 间歇性高 | ↓ 70% |
| 可扩展性 | 受限 | 良好 | ✅ |
| 可维护性 | 困难 | 容易 | ✅ |

### 关键要点

1. **PRD 摘要**：将大型 PRD 转换为轻量级摘要（节省 95%）
2. **逐章生成**：每次只处理一章，完成后立即清理
3. **文件持久化**：所有内容写入文件，不占用内存
4. **摘要传递**：章节间只传递摘要，不传递完整内容
5. **最后组装**：只在最后一步加载所有内容

通过以上策略，可以在有限的上下文中处理大型 PRD 和生成复杂的领域设计文档。
