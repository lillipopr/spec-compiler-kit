# Phase 3: 用例设计（跨端一致）

> **跨端一致性**：本文档的用例适用于所有端。
> 各端测试时使用相同的用例，确保行为一致。

## 目标

为每个不变量设计验证用例，确保系统行为可测试、可验证。

**关键原则**：用例是跨端一致的，所有端共用同一份用例文档。各端测试时使用相同的用例数据和预期结果。

---

## 用例类型（完整覆盖）

完整的用例体系应包含 6 类：

1️⃣ **正向用例**（Happy Path）
2️⃣ **边界用例**（上下限、极端值）
3️⃣ **Bad Case**（系统必须拒绝）
4️⃣ **回放用例**（可重现性验证）
5️⃣ **规则升级用例**（版本兼容性）
6️⃣ **可解释性用例**（结果可追溯）

---

## 基础用例模板

### 1-3：正向、边界、Bad Case

```
用例名称：
前置条件（Given）：
  - 系统状态：
  - 数据状态：
  - 外部依赖状态：

触发行为（When）：
  - 用户/系统做了什么

预期结果（Then）：
  - 状态变化：
  - 输出结果：
  - 副作用（日志、消息、调用）

约束/不变量：
  - 必须满足的规则

各端验证方式：
  - 后端：单元测试 / 集成测试
  - iOS：单元测试 / UI 测试
  - 前端：单元测试 / E2E 测试
```

---

## 用例示例

### Case-01：会员正常每日刷新（正向用例）

**前置条件（Given）**：
- 会员状态 = M1（生效中）
- 今日未刷新
- 点券余额 = 50

**触发行为（When）**：
- 系统触发每日刷新

**预期结果（Then）**：
- 状态变化：M1 → M1（不变）
- 输出结果：点券 +100
- 副作用：记录发放日志

**约束/不变量**：
- INV-01: 只有 M1 状态才能发放
- INV-02: 每日最多发放一次
- INV-03: 单次发放不超过 100

**各端验证方式**：
| 端 | 验证方式 | 测试文件 |
|----|---------|---------|
| 后端 | 单元测试 | CouponDomainTest.java |
| iOS | 单元测试 | CouponServiceTests.swift |
| 前端 | 单元测试 | couponService.test.ts |

---

### Case-02：非会员刷新被拒绝（Bad Case）

**前置条件（Given）**：
- 会员状态 = M0（非会员）

**触发行为（When）**：
- 系统触发刷新

**预期结果（Then）**：
- 状态变化：无
- 输出结果：拒绝发放，返回错误 "INV-01: 非会员不能发放点券"
- 副作用：无

**约束/不变量**：
- INV-01: 只有 M1 状态才能发放（违反）

**各端验证方式**：
| 端 | 验证方式 | 测试文件 |
|----|---------|---------|
| 后端 | 单元测试 | CouponDomainTest.java |
| iOS | 单元测试 | CouponServiceTests.swift |
| 前端 | - | 后端校验 |

---

### Case-03：库存恰好等于购买数量（边界用例）

**前置条件（Given）**：
- 商品库存 = 5
- 用户购买数量 = 5

**触发行为（When）**：
- 用户提交订单

**预期结果（Then）**：
- 订单创建成功
- 库存变为 0

**约束/不变量**：
- INV-02: 库存 >= 0

---

### Case-04：历史结果回放（回放用例）

**前置条件（Given）**：
- 历史答题记录 Submission-12345
- 规则版本 v1.0.0
- 原始报告分数：85 分

**触发行为（When）**：
- 使用规则 v1.0.0 重新计算

**预期结果（Then）**：
- 新报告分数 = 85 分
- 所有指标值一致
- 所有标签一致

**验证**：
```
ASSERT recalculate(submission, v1.0) == original_result
```

---

### Case-05：规则升级兼容性（版本用例）

**前置条件（Given）**：
- 同一答题记录 Submission-12345
- 规则 v1.0：M1 = Q1 + Q3
- 规则 v2.0：M1 = Q1 + Q3 + Q7（新增题目）

**触发行为（When）**：
- 分别用 v1 和 v2 计算

**预期结果（Then）**：
- v2 分数 ≥ v1 分数（单调性）
- 差异可解释：+ Q7 的贡献
- v1 和 v2 结果都有记录

---

### Case-06：测评结果可追溯（可解释性用例）

**前置条件（Given）**：
- 用户完成测评
- 测评结果已生成

**触发行为（When）**：
- 用户点击"查看结果说明"

**预期结果（Then）**：
- 显示每个维度的得分来源
- 显示影响的题目列表
- 显示判定逻辑

**约束/不变量**：
- EXP-01: 结果可追溯

---

## 用例覆盖矩阵

| 用例ID | 类型 | 覆盖不变量 | 覆盖状态转移 | 优先级 |
|--------|------|------------|--------------|--------|
| Case-01 | 正向 | INV-01, INV-02, INV-03 | M1→M1 | P0 |
| Case-02 | Bad | INV-01 | 禁止态 | P0 |
| Case-03 | 边界 | INV-02 | O0→O1 | P1 |
| Case-04 | 回放 | VER-01 | - | P1 |
| Case-05 | 版本 | VER-01 | - | P2 |
| Case-06 | 可解释性 | EXP-01 | - | P1 |

---

## 闸口检查

Phase 3 完成后，必须通过以下检查：

- [ ] 每个不变量至少有一个用例覆盖
- [ ] 每个状态转移至少有一个用例覆盖
- [ ] 每个禁止态至少有一个 Bad Case
- [ ] P0 用例 100% 覆盖
- [ ] 用例可直接转化为自动化测试
- [ ] **跨端一致性确认**：所有端使用同一份用例

## 自我验证

在进入下一阶段前，确认：

- [ ] 用例覆盖矩阵完整
- [ ] 正向用例覆盖所有核心 Happy Path
- [ ] Bad Case 覆盖所有禁止态
- [ ] 边界用例覆盖所有临界值
- [ ] 用例优先级分配合理（P0 <= 总用例数的 30%）
- [ ] **各端验证方式已明确**

---

**上一步** → [Phase 2: 可执行约束](phase-2-constraints.md)
**下一步** → [Phase 4: 端到端接口设计](phase-4-e2e-design.md)
