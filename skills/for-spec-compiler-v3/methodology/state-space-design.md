# 问题建模方法

## 目录
1. [核心原则](#核心原则)
2. [从模糊到清晰（快速开始）](#从模糊到清晰快速开始)
3. [建模步骤](#建模步骤)
4. [状态空间设计](#状态空间设计)
5. [不变量定义](#不变量定义)
6. [行为定义](#行为定义)
7. [产出文档](#产出文档)

## 核心原则

- 功能 ≠ 状态/不变量/事实
- 先定义"合法世界"，再允许系统运行
- 每个状态、行为、不变量都必须可描述、可验证

---

## 从模糊到清晰（快速开始）

### 示例：会员订阅功能

**输入（模糊需求）**：
> 用户订阅会员，每天刷新 100 点券

---

**Step 1：提炼核心实体**

问：哪些"东西"承载核心业务概念？

| 实体 | 类型 | 说明 |
|------|------|------|
| 用户 | 事实承载者 | 操作的主体 |
| 会员状态 (Membership) | 状态实体 | M0/M1/M2 |
| 点券记录 (DailyCouponGrant) | 记录实体 | 每日发放记录 |

❌ 不要一开始就设计表结构！

---

**Step 2：枚举状态（状态空间建模）**

对每个实体问：有哪些合法状态？

```Membership 状态：
- M0：非会员
- M1：会员生效中
- M2：会员已过期
```

---

**Step 3：定义状态转移**

```
M0（非会员）
  └─ 订阅成功 → M1

M1（会员生效中）
  ├─ 到期 → M2
  ├─ 续费 → M1（延长有效期）
  └─ 每日刷新 → M1（状态不变，发点券）

M2（已过期）
  └─ 再次订阅 → M1

禁止态：
❌ M0/M2 → 刷新点券（非会员不能发）
```

---

**Step 4：定义不变量（约束）**

问：业务底线是什么？必须永远成立的规则是什么？

```
INV-1：只有 M1 状态才能发放点券
INV-2：每个用户每天最多发放一次（幂等）
INV-3：同一天点券总量 ≤ 100
INV-4：会员到期当天 0 点后不得再发放
```

---

**Step 5：生成用例（覆盖状态转移）**

正向用例：
```gherkin
Case-01：会员正常每日刷新
Given：会员状态 = M1，今日未刷新
When：系统触发每日刷新
Then：点券 +100，标记已刷新
```

Bad Case：
```gherkin
Case-02：非会员刷新
Given：会员状态 = M0
When：系统触发刷新
Then：拒绝发放，状态不变
```

---

**输出（清晰模型）**：

✅ 状态定义表
✅ 状态转移表
✅ 不变量清单（可写成 assert）
✅ 用例覆盖所有转移和约束

**下一步**：根据模型推导接口和实体 → 见 [02-artifact-derivation/](../02-artifact-derivation/)

---

## 建模步骤

### Step 1：收集功能信息
- 来源：需求文档、用户故事、产品原型
- 输出：功能描述列表、功能目标

### Step 2：提炼核心实体
- 问：哪些"东西"承载核心业务概念？
- 只列最关键的实体，不急于设计表结构

### Step 3：列出状态（状态空间建模）
对每个实体问：
- 它有哪些合法状态？
- 有哪些"禁止状态"？
- 状态要清晰且可枚举

### Step 4：列出行为（状态转移和事件）
区分两类行为：
- **用户触发行为**（应用层意图）
- **系统触发行为**（定时/事件）

### Step 5：定义不变量
- 业务底线是什么？
- 必须永远成立的规则是什么？
- 用明确可执行语言描述

### Step 6：画状态转移表/图
检查：是否有遗漏状态、禁止态、非法转移

## 状态空间设计

### 状态分类
- **初始态**：系统/实体的起点
- **终止态**：不可再变更的最终状态
- **过渡态**：中间状态，可继续转移
- **禁止态**：永远不允许到达的状态

### 状态转移表格式
| 当前状态 | 事件 | 是否允许 | 下一状态 | 约束 |
|---------|------|----------|----------|------|
| S0 | 事件A | 是 | S1 | INV-1 |
| S1 | 事件B | 否 | - | 禁止态 |

## 不变量定义

### 不变量特征
- 永远为真，不是 if 判断
- 可自动验证
- 不依赖实现细节

### 不变量验证标准（极重要）

每个不变量必须通过以下三个测试：

#### ✅ 可执行测试

能否写成 assert 语句？

```python
# 自然语言描述
INV-1: 只有 M1 状态才能发放点券

# 转换为 assert
assert membership.state == "M1" or coupon_grant_amount == 0
```

```python
# 自然语言描述
INV-2: 每天最多发放一次（幂等）

# 转换为 assert
assert count_daily_grants(user_id, date) <= 1
```

#### ✅ 可测试测试

能否设计用例验证它？

```gherkin
Case: 验证 INV-1
Given：会员状态 = M0
When：触发刷新点券
Then：点券增加量 = 0
```

#### ✅ 可解释测试

能否用自然语言解释为什么它必须成立？

> INV-1 的原因：点券是会员权益，非会员不应获得，否则违反商业规则

#### ❌ 不合格示例

- "一般情况下用户应该..." → 模糊，无法验证
- "正常情况下不超过..." → 什么情况算"正常"？
- "用户不应该..." → 这是期望，不是约束

### 不变量示例
```
INV-1: 只有 M1 状态才能发放点券
INV-2: 每天最多发放一次（幂等）
INV-3: 同一天点券总量 ≤ 100
INV-4: 会员到期当天 0 点后不得再发放
```

---

**详细的不变量定义方法** → 见 [invariants.md](invariants.md)

## 行为定义

### 行为分类
| 类型 | 触发方 | 是否暴露接口 |
|------|--------|-------------|
| 用户行为 | 用户/外部系统 | 是（应用层） |
| 系统行为 | 定时任务/事件 | 否（内部） |

### 关键区分
- **意图** ≠ **事实**
- 用户发起订阅 = 意图（应用层）
- 订阅成功 = 事实（领域层）

---

## 产出文档

### 《问题建模文档》结构

#### 后端 DDD 架构
1. 核心实体列表
2. 状态定义表
3. 行为列表（用户/系统）
4. 不变量清单
5. 状态转移表/图
6. 禁止态说明

#### 移动端/Vue 前端架构
1. 核心实体列表
2. 状态定义表（业务状态）
3. 行为列表（用户/系统）
4. 不变量清单（业务不变量）
5. 状态转移表/图
6. 禁止态说明
7. **UI 状态空间** → 见 [03-platform-guide/](../03-platform-guide/)
8. **UI 不变量清单** → 见 [03-platform-guide/](../03-platform-guide/)

### 审核检查点
- [ ] 所有功能目标映射到状态或行为
- [ ] 每个状态、行为、不变量可验证
- [ ] 禁止态、边界条件已覆盖
- [ ] 模型可推导用例、接口、实体
- [ ] **前端：UI 状态空间已定义**（见平台指南）
- [ ] **前端：UI 不变量可验证**（见平台指南）
